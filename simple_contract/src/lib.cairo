#[starknet::interface] //interface of a contract represents the functions this contract exposes to the outside world

trait ISimpleStorage<TContractState>{
    fn set(ref self:TContractState,x: u128);//passing a mutable refference hence we can modify
    fn get(ref self:@TContractState)-> u128; //here we are getting a snapshot, hence we can,t modify the state
    //The functions above are public functions
}

//The contract state type is generated by the compiler, and gives access to the storage variables in the Storage Struct

#[starknet::contract]

//All smartcontracts are defined within modules
mod SimpleStorage{
    use starknet::get_caller_address;
    use starknet::ContractAddress;


    #[storage] //storage variables in starknet contracts are stored in a special struct called Storage.

    struct Storage{
        stored_data:u128
    }

    #[external(v0)]  //This attribute exposes the functions defined in the implementation below to the outside world
    //Forget to add it and your functions will not be callable from outside.

    impl SimpleStorage of super::ISimpleStorage<ContractState>{

        fn set(ref self:ContractState,x:u128){  //This is an external function i.e can mutate the contract state
            self.stored_data.write(x);
        }

        fn get(ref self:@ContractState){ //This is a view function i.e cannot mutate the contract state.
            self.stored_data.read()
        } //Both of the functions are public functions though
    }
    //when writing the implementation of the interface, the generic parameter corresponding to self argument must be ContractState
}

// fn main(){
//     set(3);
// }